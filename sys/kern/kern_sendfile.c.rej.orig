@@ -338,28 +337,12 @@
 
 		m = sfio->m;
 		mb_free_notready(m, sfio->npages);
-	} else {
-		if (so->so_snd.sb_tls_flags & SB_TLS_ACTIVE) {
-			/*
-			 * I/O operation is complete, but we still
-			 * need to encrypt.  We cannot do this in the
-			 * interrupt thread of the disk controller, so
-			 * forward the mbufs to a different thread.
-			 *
-			 * Note that the socket was referenced by
-			 * sendfile, and we're inheriting that ref,
-			 * so we do not need to do an soref() here.
-			 */
-			sbtls_enqueue(sfio->m, so, sfio->npages);
-			goto out_with_ref;
-		} else
-			(void )(so->so_proto->pr_usrreqs->pru_ready)(so,
-			    sfio->m, sfio->npages);
-	}
+	} else
+		(void )(so->so_proto->pr_usrreqs->pru_ready)(so, sfio->m,
+		    sfio->npages);
 
 	SOCK_LOCK(so);
 	sorele(so);
-out_with_ref:
 	CURVNET_RESTORE();
 	free(sfio, M_TEMP);
 }
@@ -599,10 +582,9 @@
 	off_t off, sbytes, rem, obj_size;
 	struct mbuf_ext_pgs *ext_pgs;
 	struct mbuf *m0;
-	struct sbtls_info *tls;
 	int use_ext_pgs = 0;
 	int error, softerr, bsize, hdrlen;
-	int ext_pgs_idx, max_pgs, tls_enq_cnt;
+	int ext_pgs_idx;
 
 	obj = NULL;
 	so = NULL;
@@ -778,16 +739,11 @@
 		pa = sfio->pa;
 
 		if ((mb_use_ext_pgs &&
-			so->so_proto->pr_protocol == IPPROTO_TCP) ||
-		    tls != NULL) {
+			so->so_proto->pr_protocol == IPPROTO_TCP)) {
 			/* cache state in a local, to avoid locks */
 			use_ext_pgs = 1;
-			if (tls != NULL)
-				max_pgs = num_pages(tls->sb_params.sb_maxlen);
-			else
-				max_pgs = MBUF_PEXT_MAX_PGS;
 			/* start at last index, to wrap to first */
-			ext_pgs_idx = max_pgs - 1;
+			ext_pgs_idx = MBUF_PEXT_MAX_PGS - 1;
 			m0 = NULL; /* -Wsometimes-uninitialized */
 		}
 
@@ -809,7 +765,7 @@
 				off_t xfs;
 
 				ext_pgs_idx++;
-				if (ext_pgs_idx == max_pgs) {
+				if (ext_pgs_idx == MBUF_PEXT_MAX_PGS) {
 					m0 = mb_alloc_ext_pgs(M_WAITOK, false,
 					    sendfile_free_mext_pg);
 
@@ -823,7 +779,7 @@
 						 * last page.
 						 */
 						if ((i + min(npages - i,
-						    max_pgs) == npages) &&
+						    MBUF_PEXT_MAX_PGS) == npages) &&
 						    ((off + space) & PAGE_MASK) &&
 						    (rem > space || rhpages > 0))
 							m0->m_ext.ext_flags |=
